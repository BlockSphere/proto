// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: proto/user.proto

package userpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_CreateUser_FullMethodName                = "/user.UserService/CreateUser"
	UserService_GetUser_FullMethodName                   = "/user.UserService/GetUser"
	UserService_UpdateUser_FullMethodName                = "/user.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName                = "/user.UserService/DeleteUser"
	UserService_UpdateAvatar_FullMethodName              = "/user.UserService/UpdateAvatar"
	UserService_GetAvatar_FullMethodName                 = "/user.UserService/GetAvatar"
	UserService_UpdateFcmToken_FullMethodName            = "/user.UserService/UpdateFcmToken"
	UserService_GetFcmToken_FullMethodName               = "/user.UserService/GetFcmToken"
	UserService_CreateLocation_FullMethodName            = "/user.UserService/CreateLocation"
	UserService_GetLocations_FullMethodName              = "/user.UserService/GetLocations"
	UserService_UpdateLocation_FullMethodName            = "/user.UserService/UpdateLocation"
	UserService_DeleteLocation_FullMethodName            = "/user.UserService/DeleteLocation"
	UserService_CreateGreenhouse_FullMethodName          = "/user.UserService/CreateGreenhouse"
	UserService_GetGreenhouses_FullMethodName            = "/user.UserService/GetGreenhouses"
	UserService_UpdateGreenhouse_FullMethodName          = "/user.UserService/UpdateGreenhouse"
	UserService_DeleteGreenhouse_FullMethodName          = "/user.UserService/DeleteGreenhouse"
	UserService_CreateThreshold_FullMethodName           = "/user.UserService/CreateThreshold"
	UserService_GetThresholds_FullMethodName             = "/user.UserService/GetThresholds"
	UserService_UpdateThreshold_FullMethodName           = "/user.UserService/UpdateThreshold"
	UserService_DeleteThreshold_FullMethodName           = "/user.UserService/DeleteThreshold"
	UserService_GetSettings_FullMethodName               = "/user.UserService/GetSettings"
	UserService_UpdateSettings_FullMethodName            = "/user.UserService/UpdateSettings"
	UserService_GetUserInfoFromGreenhouse_FullMethodName = "/user.UserService/GetUserInfoFromGreenhouse"
	UserService_GetUserByEmail_FullMethodName            = "/user.UserService/GetUserByEmail"
	UserService_CreateSensor_FullMethodName              = "/user.UserService/CreateSensor"
	UserService_UpdateSensor_FullMethodName              = "/user.UserService/UpdateSensor"
	UserService_DeleteSensor_FullMethodName              = "/user.UserService/DeleteSensor"
	UserService_GetSensorsByGreenhouse_FullMethodName    = "/user.UserService/GetSensorsByGreenhouse"
	UserService_GetSensor_FullMethodName                 = "/user.UserService/GetSensor"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	GetUser(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*UserResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	DeleteUser(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	UpdateAvatar(ctx context.Context, in *UpdateAvatarRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	GetAvatar(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*AvatarResponse, error)
	UpdateFcmToken(ctx context.Context, in *UpdateFcmTokenRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	GetFcmToken(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*FcmTokenResponse, error)
	CreateLocation(ctx context.Context, in *CreateLocationRequest, opts ...grpc.CallOption) (*Location, error)
	GetLocations(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*LocationListResponse, error)
	UpdateLocation(ctx context.Context, in *UpdateLocationRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	DeleteLocation(ctx context.Context, in *LocationIdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	CreateGreenhouse(ctx context.Context, in *CreateGreenhouseRequest, opts ...grpc.CallOption) (*Greenhouse, error)
	GetGreenhouses(ctx context.Context, in *GreenhouseListRequest, opts ...grpc.CallOption) (*GreenhouseListResponse, error)
	UpdateGreenhouse(ctx context.Context, in *UpdateGreenhouseRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	DeleteGreenhouse(ctx context.Context, in *GreenhouseIdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	CreateThreshold(ctx context.Context, in *CreateThresholdRequest, opts ...grpc.CallOption) (*Threshold, error)
	GetThresholds(ctx context.Context, in *ThresholdRequest, opts ...grpc.CallOption) (*ThresholdResponse, error)
	UpdateThreshold(ctx context.Context, in *UpdateThresholdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	DeleteThreshold(ctx context.Context, in *ThresholdIdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	GetSettings(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	GetUserInfoFromGreenhouse(ctx context.Context, in *UserInfoRequestFromGreenhouse, opts ...grpc.CallOption) (*UserInfoResponseFromGreenhouse, error)
	GetUserByEmail(ctx context.Context, in *EmailRequest, opts ...grpc.CallOption) (*UserResponse, error)
	CreateSensor(ctx context.Context, in *CreateSensorRequest, opts ...grpc.CallOption) (*Sensor, error)
	UpdateSensor(ctx context.Context, in *UpdateSensorRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	DeleteSensor(ctx context.Context, in *SensorIdRequest, opts ...grpc.CallOption) (*UserEmpty, error)
	GetSensorsByGreenhouse(ctx context.Context, in *SensorListRequest, opts ...grpc.CallOption) (*SensorListResponse, error)
	GetSensor(ctx context.Context, in *SensorIdRequest, opts ...grpc.CallOption) (*Sensor, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateAvatar(ctx context.Context, in *UpdateAvatarRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetAvatar(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*AvatarResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvatarResponse)
	err := c.cc.Invoke(ctx, UserService_GetAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateFcmToken(ctx context.Context, in *UpdateFcmTokenRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateFcmToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetFcmToken(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*FcmTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FcmTokenResponse)
	err := c.cc.Invoke(ctx, UserService_GetFcmToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateLocation(ctx context.Context, in *CreateLocationRequest, opts ...grpc.CallOption) (*Location, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Location)
	err := c.cc.Invoke(ctx, UserService_CreateLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetLocations(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*LocationListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocationListResponse)
	err := c.cc.Invoke(ctx, UserService_GetLocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateLocation(ctx context.Context, in *UpdateLocationRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteLocation(ctx context.Context, in *LocationIdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_DeleteLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateGreenhouse(ctx context.Context, in *CreateGreenhouseRequest, opts ...grpc.CallOption) (*Greenhouse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Greenhouse)
	err := c.cc.Invoke(ctx, UserService_CreateGreenhouse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetGreenhouses(ctx context.Context, in *GreenhouseListRequest, opts ...grpc.CallOption) (*GreenhouseListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GreenhouseListResponse)
	err := c.cc.Invoke(ctx, UserService_GetGreenhouses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateGreenhouse(ctx context.Context, in *UpdateGreenhouseRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateGreenhouse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteGreenhouse(ctx context.Context, in *GreenhouseIdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_DeleteGreenhouse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateThreshold(ctx context.Context, in *CreateThresholdRequest, opts ...grpc.CallOption) (*Threshold, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Threshold)
	err := c.cc.Invoke(ctx, UserService_CreateThreshold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetThresholds(ctx context.Context, in *ThresholdRequest, opts ...grpc.CallOption) (*ThresholdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ThresholdResponse)
	err := c.cc.Invoke(ctx, UserService_GetThresholds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateThreshold(ctx context.Context, in *UpdateThresholdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateThreshold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteThreshold(ctx context.Context, in *ThresholdIdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_DeleteThreshold_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetSettings(ctx context.Context, in *UserIdRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, UserService_GetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfoFromGreenhouse(ctx context.Context, in *UserInfoRequestFromGreenhouse, opts ...grpc.CallOption) (*UserInfoResponseFromGreenhouse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfoResponseFromGreenhouse)
	err := c.cc.Invoke(ctx, UserService_GetUserInfoFromGreenhouse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserByEmail(ctx context.Context, in *EmailRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateSensor(ctx context.Context, in *CreateSensorRequest, opts ...grpc.CallOption) (*Sensor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Sensor)
	err := c.cc.Invoke(ctx, UserService_CreateSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateSensor(ctx context.Context, in *UpdateSensorRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_UpdateSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteSensor(ctx context.Context, in *SensorIdRequest, opts ...grpc.CallOption) (*UserEmpty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEmpty)
	err := c.cc.Invoke(ctx, UserService_DeleteSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetSensorsByGreenhouse(ctx context.Context, in *SensorListRequest, opts ...grpc.CallOption) (*SensorListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SensorListResponse)
	err := c.cc.Invoke(ctx, UserService_GetSensorsByGreenhouse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetSensor(ctx context.Context, in *SensorIdRequest, opts ...grpc.CallOption) (*Sensor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Sensor)
	err := c.cc.Invoke(ctx, UserService_GetSensor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error)
	GetUser(context.Context, *UserIdRequest) (*UserResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UserEmpty, error)
	DeleteUser(context.Context, *UserIdRequest) (*UserEmpty, error)
	UpdateAvatar(context.Context, *UpdateAvatarRequest) (*UserEmpty, error)
	GetAvatar(context.Context, *UserIdRequest) (*AvatarResponse, error)
	UpdateFcmToken(context.Context, *UpdateFcmTokenRequest) (*UserEmpty, error)
	GetFcmToken(context.Context, *UserIdRequest) (*FcmTokenResponse, error)
	CreateLocation(context.Context, *CreateLocationRequest) (*Location, error)
	GetLocations(context.Context, *UserIdRequest) (*LocationListResponse, error)
	UpdateLocation(context.Context, *UpdateLocationRequest) (*UserEmpty, error)
	DeleteLocation(context.Context, *LocationIdRequest) (*UserEmpty, error)
	CreateGreenhouse(context.Context, *CreateGreenhouseRequest) (*Greenhouse, error)
	GetGreenhouses(context.Context, *GreenhouseListRequest) (*GreenhouseListResponse, error)
	UpdateGreenhouse(context.Context, *UpdateGreenhouseRequest) (*UserEmpty, error)
	DeleteGreenhouse(context.Context, *GreenhouseIdRequest) (*UserEmpty, error)
	CreateThreshold(context.Context, *CreateThresholdRequest) (*Threshold, error)
	GetThresholds(context.Context, *ThresholdRequest) (*ThresholdResponse, error)
	UpdateThreshold(context.Context, *UpdateThresholdRequest) (*UserEmpty, error)
	DeleteThreshold(context.Context, *ThresholdIdRequest) (*UserEmpty, error)
	GetSettings(context.Context, *UserIdRequest) (*SettingsResponse, error)
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*UserEmpty, error)
	GetUserInfoFromGreenhouse(context.Context, *UserInfoRequestFromGreenhouse) (*UserInfoResponseFromGreenhouse, error)
	GetUserByEmail(context.Context, *EmailRequest) (*UserResponse, error)
	CreateSensor(context.Context, *CreateSensorRequest) (*Sensor, error)
	UpdateSensor(context.Context, *UpdateSensorRequest) (*UserEmpty, error)
	DeleteSensor(context.Context, *SensorIdRequest) (*UserEmpty, error)
	GetSensorsByGreenhouse(context.Context, *SensorListRequest) (*SensorListResponse, error)
	GetSensor(context.Context, *SensorIdRequest) (*Sensor, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *UserIdRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *UserIdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateAvatar(context.Context, *UpdateAvatarRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAvatar not implemented")
}
func (UnimplementedUserServiceServer) GetAvatar(context.Context, *UserIdRequest) (*AvatarResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvatar not implemented")
}
func (UnimplementedUserServiceServer) UpdateFcmToken(context.Context, *UpdateFcmTokenRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFcmToken not implemented")
}
func (UnimplementedUserServiceServer) GetFcmToken(context.Context, *UserIdRequest) (*FcmTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFcmToken not implemented")
}
func (UnimplementedUserServiceServer) CreateLocation(context.Context, *CreateLocationRequest) (*Location, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLocation not implemented")
}
func (UnimplementedUserServiceServer) GetLocations(context.Context, *UserIdRequest) (*LocationListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocations not implemented")
}
func (UnimplementedUserServiceServer) UpdateLocation(context.Context, *UpdateLocationRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLocation not implemented")
}
func (UnimplementedUserServiceServer) DeleteLocation(context.Context, *LocationIdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLocation not implemented")
}
func (UnimplementedUserServiceServer) CreateGreenhouse(context.Context, *CreateGreenhouseRequest) (*Greenhouse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGreenhouse not implemented")
}
func (UnimplementedUserServiceServer) GetGreenhouses(context.Context, *GreenhouseListRequest) (*GreenhouseListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGreenhouses not implemented")
}
func (UnimplementedUserServiceServer) UpdateGreenhouse(context.Context, *UpdateGreenhouseRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGreenhouse not implemented")
}
func (UnimplementedUserServiceServer) DeleteGreenhouse(context.Context, *GreenhouseIdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGreenhouse not implemented")
}
func (UnimplementedUserServiceServer) CreateThreshold(context.Context, *CreateThresholdRequest) (*Threshold, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateThreshold not implemented")
}
func (UnimplementedUserServiceServer) GetThresholds(context.Context, *ThresholdRequest) (*ThresholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetThresholds not implemented")
}
func (UnimplementedUserServiceServer) UpdateThreshold(context.Context, *UpdateThresholdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateThreshold not implemented")
}
func (UnimplementedUserServiceServer) DeleteThreshold(context.Context, *ThresholdIdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteThreshold not implemented")
}
func (UnimplementedUserServiceServer) GetSettings(context.Context, *UserIdRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSettings not implemented")
}
func (UnimplementedUserServiceServer) UpdateSettings(context.Context, *UpdateSettingsRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfoFromGreenhouse(context.Context, *UserInfoRequestFromGreenhouse) (*UserInfoResponseFromGreenhouse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfoFromGreenhouse not implemented")
}
func (UnimplementedUserServiceServer) GetUserByEmail(context.Context, *EmailRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByEmail not implemented")
}
func (UnimplementedUserServiceServer) CreateSensor(context.Context, *CreateSensorRequest) (*Sensor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSensor not implemented")
}
func (UnimplementedUserServiceServer) UpdateSensor(context.Context, *UpdateSensorRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSensor not implemented")
}
func (UnimplementedUserServiceServer) DeleteSensor(context.Context, *SensorIdRequest) (*UserEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSensor not implemented")
}
func (UnimplementedUserServiceServer) GetSensorsByGreenhouse(context.Context, *SensorListRequest) (*SensorListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensorsByGreenhouse not implemented")
}
func (UnimplementedUserServiceServer) GetSensor(context.Context, *SensorIdRequest) (*Sensor, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensor not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAvatarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateAvatar(ctx, req.(*UpdateAvatarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetAvatar(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateFcmToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFcmTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateFcmToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateFcmToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateFcmToken(ctx, req.(*UpdateFcmTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetFcmToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetFcmToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetFcmToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetFcmToken(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateLocation(ctx, req.(*CreateLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetLocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetLocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetLocations(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateLocation(ctx, req.(*UpdateLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteLocation(ctx, req.(*LocationIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateGreenhouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGreenhouseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateGreenhouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateGreenhouse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateGreenhouse(ctx, req.(*CreateGreenhouseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetGreenhouses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreenhouseListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetGreenhouses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetGreenhouses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetGreenhouses(ctx, req.(*GreenhouseListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateGreenhouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGreenhouseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateGreenhouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateGreenhouse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateGreenhouse(ctx, req.(*UpdateGreenhouseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteGreenhouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreenhouseIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteGreenhouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteGreenhouse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteGreenhouse(ctx, req.(*GreenhouseIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateThresholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateThreshold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateThreshold(ctx, req.(*CreateThresholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetThresholds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThresholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetThresholds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetThresholds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetThresholds(ctx, req.(*ThresholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateThresholdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateThreshold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateThreshold(ctx, req.(*UpdateThresholdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThresholdIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteThreshold_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteThreshold(ctx, req.(*ThresholdIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetSettings(ctx, req.(*UserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfoFromGreenhouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoRequestFromGreenhouse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfoFromGreenhouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfoFromGreenhouse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfoFromGreenhouse(ctx, req.(*UserInfoRequestFromGreenhouse))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserByEmail(ctx, req.(*EmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateSensor(ctx, req.(*CreateSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSensorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateSensor(ctx, req.(*UpdateSensorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteSensor(ctx, req.(*SensorIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetSensorsByGreenhouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetSensorsByGreenhouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetSensorsByGreenhouse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetSensorsByGreenhouse(ctx, req.(*SensorListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetSensor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetSensor(ctx, req.(*SensorIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "UpdateAvatar",
			Handler:    _UserService_UpdateAvatar_Handler,
		},
		{
			MethodName: "GetAvatar",
			Handler:    _UserService_GetAvatar_Handler,
		},
		{
			MethodName: "UpdateFcmToken",
			Handler:    _UserService_UpdateFcmToken_Handler,
		},
		{
			MethodName: "GetFcmToken",
			Handler:    _UserService_GetFcmToken_Handler,
		},
		{
			MethodName: "CreateLocation",
			Handler:    _UserService_CreateLocation_Handler,
		},
		{
			MethodName: "GetLocations",
			Handler:    _UserService_GetLocations_Handler,
		},
		{
			MethodName: "UpdateLocation",
			Handler:    _UserService_UpdateLocation_Handler,
		},
		{
			MethodName: "DeleteLocation",
			Handler:    _UserService_DeleteLocation_Handler,
		},
		{
			MethodName: "CreateGreenhouse",
			Handler:    _UserService_CreateGreenhouse_Handler,
		},
		{
			MethodName: "GetGreenhouses",
			Handler:    _UserService_GetGreenhouses_Handler,
		},
		{
			MethodName: "UpdateGreenhouse",
			Handler:    _UserService_UpdateGreenhouse_Handler,
		},
		{
			MethodName: "DeleteGreenhouse",
			Handler:    _UserService_DeleteGreenhouse_Handler,
		},
		{
			MethodName: "CreateThreshold",
			Handler:    _UserService_CreateThreshold_Handler,
		},
		{
			MethodName: "GetThresholds",
			Handler:    _UserService_GetThresholds_Handler,
		},
		{
			MethodName: "UpdateThreshold",
			Handler:    _UserService_UpdateThreshold_Handler,
		},
		{
			MethodName: "DeleteThreshold",
			Handler:    _UserService_DeleteThreshold_Handler,
		},
		{
			MethodName: "GetSettings",
			Handler:    _UserService_GetSettings_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _UserService_UpdateSettings_Handler,
		},
		{
			MethodName: "GetUserInfoFromGreenhouse",
			Handler:    _UserService_GetUserInfoFromGreenhouse_Handler,
		},
		{
			MethodName: "GetUserByEmail",
			Handler:    _UserService_GetUserByEmail_Handler,
		},
		{
			MethodName: "CreateSensor",
			Handler:    _UserService_CreateSensor_Handler,
		},
		{
			MethodName: "UpdateSensor",
			Handler:    _UserService_UpdateSensor_Handler,
		},
		{
			MethodName: "DeleteSensor",
			Handler:    _UserService_DeleteSensor_Handler,
		},
		{
			MethodName: "GetSensorsByGreenhouse",
			Handler:    _UserService_GetSensorsByGreenhouse_Handler,
		},
		{
			MethodName: "GetSensor",
			Handler:    _UserService_GetSensor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user.proto",
}
